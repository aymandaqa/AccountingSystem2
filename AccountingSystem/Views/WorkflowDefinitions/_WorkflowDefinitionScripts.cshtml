@using System.Collections.Generic
@using AccountingSystem.ViewModels.Workflows
@model WorkflowDefinitionViewModel
@{
    var usersJson = ViewData["WorkflowUsersJson"] as string ?? "[]";
    var permissionsJson = ViewData["WorkflowPermissionsJson"] as string ?? "[]";
    var branchesJson = ViewData["WorkflowBranchesJson"] as string ?? "[]";
    var existingStepsJson = System.Text.Json.JsonSerializer.Serialize(Model.Steps ?? new List<WorkflowStepInputModel>());
}

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
    (function () {
        const users = @Html.Raw(usersJson);
        const permissions = @Html.Raw(permissionsJson);
        const branches = @Html.Raw(branchesJson);
        const existingSteps = @Html.Raw(existingStepsJson);
        const stepsList = document.getElementById('stepsList');
        const stepsJsonInput = document.getElementById('stepsJson');
        const noStepsMessage = document.getElementById('noStepsMessage');
        const addStepBtn = document.getElementById('addStepBtn');
        const clearStepsBtn = document.getElementById('clearStepsBtn');
        const expressionOutput = document.getElementById('expressionOutput');
        let stepCounter = 0;

        if (!stepsList || !stepsJsonInput || !noStepsMessage || !addStepBtn) {
            return;
        }

        function createOption(value, text) {
            const option = document.createElement('option');
            option.value = value ?? '';
            option.textContent = text;
            return option;
        }

        function toggleEmptyMessage() {
            const hasSteps = stepsList.children.length > 0;
            noStepsMessage.style.display = hasSteps ? 'none' : 'block';
            if (!hasSteps && expressionOutput) {
                expressionOutput.textContent = 'لا يوجد تعبير بعد';
            }
        }

        function getTypeLabel(type) {
            if (type === 2) return 'حسب الصلاحية';
            if (type === 3) return 'مسؤولو الفرع';
            return 'مستخدم محدد';
        }

        function updateExpressionOutput() {
            if (!expressionOutput) return;

            const stepElements = Array.from(stepsList.querySelectorAll('.workflow-step'));
            if (stepElements.length === 0) {
                expressionOutput.textContent = 'لا يوجد تعبير بعد';
                return;
            }

            const labelMap = new Map();
            stepElements.forEach((el, idx) => {
                const type = parseInt(el.querySelector('.step-type').value);
                const typeLabel = getTypeLabel(type);
                labelMap.set(el.dataset.stepId, `${idx + 1} - ${typeLabel}`);
            });

            const childrenMap = new Map();

            stepElements.forEach((el) => {
                const requiresParent = el.querySelector('.step-has-parent')?.checked;
                const parentId = requiresParent ? el.querySelector('.step-parent').value : '';

                if (parentId) {
                    const list = childrenMap.get(parentId) || [];
                    list.push(el);
                    childrenMap.set(parentId, list);
                }
            });

            const buildExpression = (element, visited = new Set()) => {
                const currentId = element.dataset.stepId;
                if (visited.has(currentId)) {
                    return labelMap.get(currentId) || 'خطوة';
                }

                visited.add(currentId);
                let expression = labelMap.get(currentId) || 'خطوة';
                const children = childrenMap.get(currentId) || [];

                children.forEach(child => {
                    const connectorValue = parseInt(child.querySelector('.step-connector').value) || 1;
                    const connectorLabel = connectorValue === 2 ? 'OR' : 'AND';
                    const childExpression = buildExpression(child, new Set(visited));
                    expression = `(${expression} ${connectorLabel} ${childExpression})`;
                });

                return expression;
            };

            const roots = stepElements.filter(el => {
                const requiresParent = el.querySelector('.step-has-parent')?.checked;
                const parentId = requiresParent ? el.querySelector('.step-parent').value : '';
                return !parentId || !labelMap.has(parentId);
            });

            const expressions = roots.map(root => buildExpression(root));
            if (expressions.length === 0) {
                expressionOutput.textContent = 'التعبير غير مكتمل بسبب غياب الخطوات الجذرية';
                return;
            }

            expressionOutput.textContent = expressions.join('  ،  ');
        }

        function getStepLabel(stepElement, index) {
            const type = parseInt(stepElement.querySelector('.step-type').value);
            const connector = parseInt(stepElement.querySelector('.step-connector').value);
            const hasParent = stepElement.querySelector('.step-has-parent')?.checked;
            const connectorLabel = connector === 2 ? 'أو' : 'و';
            const typeLabel = getTypeLabel(type);

            return hasParent
                ? `${index + 1} - (${connectorLabel}) ${typeLabel}`
                : `${index + 1} - ${typeLabel}`;
        }

        function refreshParentOptions() {
            const elements = Array.from(stepsList.querySelectorAll('.workflow-step'));
            elements.forEach((element, idx) => {
                const select = element.querySelector('.step-parent');
                if (!select) return;

                const selected = select.value;
                select.innerHTML = '';
                select.appendChild(createOption('', 'بدون أب'));

                elements.forEach((candidate, candidateIdx) => {
                    if (candidate === element) return;
                    const option = createOption(candidate.dataset.stepId, getStepLabel(candidate, candidateIdx));
                    select.appendChild(option);
                });

                const preferredParent = element.dataset.parentStepId || selected || element.dataset.parentOrder;
                if (preferredParent) {
                    select.value = preferredParent;
                }
            });
        }

        function buildStepElement(step) {
            const container = document.createElement('div');
            container.className = 'list-group-item workflow-step mb-2';
            container.innerHTML = `
                <div class="d-flex justify-content-between align-items-start">
                    <div class="flex-grow-1">
                        <div class="row g-2 align-items-end">
                            <div class="col-md-2 step-connector-container">
                                <label class="form-label">نوع الربط</label>
                                <select class="form-select step-connector">
                                    <option value="1">و (AND)</option>
                                    <option value="2">أو (OR)</option>
                                </select>
                            </div>
                            <div class="col-md-3">
                                <label class="form-label">نوع الخطوة</label>
                                <select class="form-select step-type">
                                    <option value="1">مستخدم محدد</option>
                                    <option value="2">حسب الصلاحية</option>
                                    <option value="3">مسؤولو الفرع</option>
                                </select>
                            </div>
                            <div class="col-md-3 step-parent-container">
                                <label class="form-label">الخطوة الأب</label>
                                <select class="form-select step-parent">
                                    <option value="">بدون أب</option>
                                </select>
                            </div>
                            <div class="col-md-2">
                                <div class="form-check mt-4 pt-2">
                                    <input type="checkbox" class="form-check-input step-has-parent" />
                                    <label class="form-check-label">تتطلب خطوة سابقة</label>
                                </div>
                            </div>
                            <div class="col-md-3 step-user-container">
                                <label class="form-label">المستخدم</label>
                                <select class="form-select step-user">
                                    <option value="">اختر المستخدم</option>
                                </select>
                            </div>
                            <div class="col-md-3 step-permission-container">
                                <label class="form-label">الصلاحية</label>
                                <select class="form-select step-permission">
                                    <option value="">اختر الصلاحية</option>
                                </select>
                            </div>
                            <div class="col-md-3 step-branch-container">
                                <label class="form-label">الفرع</label>
                                <select class="form-select step-branch">
                                    <option value="">اختر الفرع</option>
                                </select>
                            </div>
                            <div class="col-md-3">
                                <label class="form-label">الحد الأدنى للمبلغ</label>
                                <input type="number" class="form-control step-min-amount" step="0.01" />
                            </div>
                            <div class="col-md-3">
                                <label class="form-label">الحد الأقصى للمبلغ</label>
                                <input type="number" class="form-control step-max-amount" step="0.01" />
                            </div>
                        </div>
                    </div>
                    <div class="ms-2">
                        <button type="button" class="btn btn-outline-danger btn-sm remove-step"><i class="fa fa-trash"></i></button>
                    </div>
                </div>`;

            const typeSelect = container.querySelector('.step-type');
            const connectorSelect = container.querySelector('.step-connector');
            const parentSelect = container.querySelector('.step-parent');
            const userSelect = container.querySelector('.step-user');
            const permissionSelect = container.querySelector('.step-permission');
            const branchSelect = container.querySelector('.step-branch');
            const minAmountInput = container.querySelector('.step-min-amount');
            const maxAmountInput = container.querySelector('.step-max-amount');
            const hasParentCheckbox = container.querySelector('.step-has-parent');
            const connectorContainer = container.querySelector('.step-connector-container');
            const parentContainer = container.querySelector('.step-parent-container');

            let stepId = step.internalId || step.InternalId || step.id || step.Id;
            if (!stepId) {
                stepCounter += 1;
                stepId = `new-${stepCounter}`;
            } else if (!isNaN(parseInt(stepId))) {
                stepCounter = Math.max(stepCounter, parseInt(stepId));
            }

            container.dataset.stepId = stepId;

            const requiresParent = Boolean(step.parentStepId || step.ParentStepId || step.parentOrder || step.ParentOrder);
            if (hasParentCheckbox) {
                hasParentCheckbox.checked = requiresParent;
            }

            users.forEach(user => userSelect.appendChild(createOption(user.id ?? user.Id, user.name ?? user.Name)));
            permissions.forEach(permission => permissionSelect.appendChild(createOption(permission.name ?? permission.Name, permission.displayName ?? permission.DisplayName)));
            branches.forEach(branch => branchSelect.appendChild(createOption(branch.id ?? branch.Id, branch.name ?? branch.Name)));

            typeSelect.value = step.stepType || step.StepType || '1';
            connectorSelect.value = step.connector || step.Connector || '1';
            container.dataset.parentStepId = step.parentStepId || step.ParentStepId || '';
            if (step.approverUserId || step.ApproverUserId) {
                userSelect.value = step.approverUserId || step.ApproverUserId;
            }
            if (step.requiredPermission || step.RequiredPermission) {
                permissionSelect.value = step.requiredPermission || step.RequiredPermission;
            }
            if (step.branchId || step.BranchId) {
                branchSelect.value = step.branchId || step.BranchId;
            }
            const initialMin = step.minAmount ?? step.MinAmount;
            const initialMax = step.maxAmount ?? step.MaxAmount;
            if (initialMin !== undefined && initialMin !== null) {
                minAmountInput.value = initialMin;
            }
            if (initialMax !== undefined && initialMax !== null) {
                maxAmountInput.value = initialMax;
            }

            container.dataset.parentOrder = step.parentOrder || step.ParentOrder || '';

            function updateVisibility() {
                const type = parseInt(typeSelect.value);
                container.querySelector('.step-user-container').style.display = type === 1 ? 'block' : 'none';
                container.querySelector('.step-permission-container').style.display = type === 2 ? 'block' : 'none';
                container.querySelector('.step-branch-container').style.display = type === 3 ? 'block' : 'none';
            }

            function updateParentState() {
                const enabled = hasParentCheckbox?.checked;
                const displayStyle = enabled ? 'block' : 'none';
                if (parentSelect) {
                    parentSelect.disabled = !enabled;
                    if (!enabled) {
                        parentSelect.value = '';
                        container.dataset.parentStepId = '';
                        container.dataset.parentOrder = '';
                    }
                }
                if (connectorSelect) {
                    connectorSelect.disabled = !enabled;
                    if (!enabled) {
                        connectorSelect.value = '1';
                    }
                }
                if (parentContainer) parentContainer.style.display = displayStyle;
                if (connectorContainer) connectorContainer.style.display = displayStyle;
            }

            typeSelect.addEventListener('change', updateVisibility);
            updateVisibility();

            if (hasParentCheckbox) {
                hasParentCheckbox.addEventListener('change', function () {
                    updateParentState();
                    refreshParentOptions();
                    serializeSteps();
                });
            }
            updateParentState();

            container.querySelector('.remove-step').addEventListener('click', function () {
                container.remove();
                toggleEmptyMessage();
                refreshParentOptions();
                serializeSteps();
            });

            return container;
        }

        function addStep(step = {}) {
            const element = buildStepElement(step);
            stepsList.appendChild(element);
            toggleEmptyMessage();
            refreshParentOptions();
            serializeSteps();
            updateExpressionOutput();
        }

        addStepBtn.addEventListener('click', function () {
            addStep({ stepType: 1 });
        });

        clearStepsBtn?.addEventListener('click', function () {
            stepsList.innerHTML = '';
            toggleEmptyMessage();
            serializeSteps();
            updateExpressionOutput();
        });

        if (window.Sortable) {
            Sortable.create(stepsList, {
                animation: 150,
                handle: '.workflow-step',
                onUpdate: () => {
                    refreshParentOptions();
                    serializeSteps();
                }
            });
        } else {
            console.warn('Sortable library not loaded; drag-and-drop ordering disabled.');
        }

        function serializeSteps() {
            const steps = [];
            const stepElements = Array.from(stepsList.querySelectorAll('.workflow-step'));
            const orderMap = new Map();
            stepElements.forEach((el, idx) => orderMap.set(el.dataset.stepId, idx + 1));

            stepElements.forEach((element, index) => {
                const type = parseInt(element.querySelector('.step-type').value);
                const requiresParent = element.querySelector('.step-has-parent')?.checked;
                const parentValue = requiresParent ? element.querySelector('.step-parent').value : '';
                const parentStepId = parentValue ? parseInt(parentValue) : null;
                const connectorValue = requiresParent ? parseInt(element.querySelector('.step-connector').value) || 1 : 1;
                const step = {
                    Order: index + 1,
                    Connector: connectorValue,
                    StepType: type
                };

                step.ParentOrder = requiresParent && parentValue && orderMap.has(parentValue)
                    ? orderMap.get(parentValue)
                    : null;
                step.ParentStepId = requiresParent ? parentStepId : null;
                step.InternalId = element.dataset.stepId;

                if (type === 1) {
                    const userValue = element.querySelector('.step-user').value;
                    step.ApproverUserId = userValue || null;
                } else if (type === 2) {
                    const permissionValue = element.querySelector('.step-permission').value;
                    step.RequiredPermission = permissionValue || null;
                } else if (type === 3) {
                    const branchValue = element.querySelector('.step-branch').value;
                    step.BranchId = branchValue ? parseInt(branchValue) : null;
                }

                const minAmountValue = element.querySelector('.step-min-amount').value;
                const maxAmountValue = element.querySelector('.step-max-amount').value;
                step.MinAmount = minAmountValue !== '' ? parseFloat(minAmountValue) : null;
                step.MaxAmount = maxAmountValue !== '' ? parseFloat(maxAmountValue) : null;

                steps.push(step);
            });

            stepsJsonInput.value = JSON.stringify(steps);
            updateExpressionOutput();
        }

        stepsList.addEventListener('change', function (event) {
            const target = event.target;
            if (target && (target.classList.contains('step-type') || target.classList.contains('step-user') || target.classList.contains('step-permission') || target.classList.contains('step-branch'))) {
                if (target.classList.contains('step-type')) {
                    refreshParentOptions();
                }
                serializeSteps();
            }
            if (target && target.classList.contains('step-connector')) {
                refreshParentOptions();
                serializeSteps();
            }
            if (target && target.classList.contains('step-parent')) {
                const stepElement = target.closest('.workflow-step');
                stepElement.dataset.parentStepId = target.value;
                serializeSteps();
            }
        });

        stepsList.addEventListener('input', function (event) {
            const target = event.target;
            if (target && (target.classList.contains('step-min-amount') || target.classList.contains('step-max-amount'))) {
                serializeSteps();
            }
        });

        const form = stepsJsonInput?.form;
        if (form) {
            form.addEventListener('submit', function () {
                serializeSteps();
            });
        }

        const stepsArray = Array.isArray(existingSteps) ? existingSteps : [];
        if (stepsArray.length > 0) {
            stepsArray.forEach(step => addStep(step));
        }

        toggleEmptyMessage();
    })();
</script>
